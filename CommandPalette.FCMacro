# TODO: fuzzy search?
# TODO: better visuals:
#         see: https://stackoverflow.com/questions/41107202/pyqt-coloring-part-of-text-in-qlistwidget
#           - better path: right-aligned + grey
#           - show the keyboard shortcut for the item?


# Useful methods on QAction menu items
# text(): The text of the menu item with '&' before the shortcut key.
# toolTip(): on hover tooltip as html.
# shortcut(): shortcut keys for that action as a QKeySequence.
# trigger(): invoke that action.

import PySide2

def enumerateActions(menu, path=[]):
    actionList = []
    for action in menu.actions():
        if action.isSeparator():
            pass
        elif action.menu():
            actionList.extend(enumerateActions(action.menu(), path + [action.text()]))
        else:
            actionList.append((action, path))
    return actionList

def getMenuItems():
    def convertAction(action, path):
        # For an unknown reason, there are a bunch of blank menu items -- filter them out.
        if not action.text():
            return None

        pathText = "->".join(path)
        fullText = f"{action.text()} ({pathText})"
        # fixedText = action.text().replace('&', '')
        fixedText = fullText.replace('&', '')

        item = PaletteListWidgetItem()
        item.setText(fixedText)
        item.setSearchText(fixedText.casefold())
        item.setToolTip(action.toolTip())
        item.setIcon(action.icon())
        item.setTrigger(action.trigger)
        return item

    mw = Gui.getMainWindow()
    menuBar = mw.menuBar()
    return [convertAction(action, path) for action, path in enumerateActions(menuBar) if action is not None]
    
class PaletteListWidgetItem(PySide2.QtWidgets.QListWidgetItem):
    _searchText = None
    _trigger = None

    def searchText(self):
        return self._searchText

    def setSearchText(self,text):
        self._searchText = text

    def runTrigger(self):
        self._trigger()

    def setTrigger(self, trigger):
        self._trigger = trigger

class PaletteLineEdit(PySide2.QtWidgets.QLineEdit):
    keyMappings = {}

    def keyPressEvent(self, event):
        keyFn = self.keyMappings.get(event.key())
        if keyFn is not None:
            keyFn()
            return

        super().keyPressEvent(event)

    def setMappings(self, keyMappings):
        self.keyMappings = keyMappings

class CommandPalette:
    MIN_DIALOG_WIDTH = 600
    MIN_DIALOG_HEIGHT = 400
    def activate(self):
        items = getMenuItems()
        dialog = PySide2.QtWidgets.QWidget()
        dialog.setObjectName("CommandPalette")
        dialog.setMinimumWidth(self.MIN_DIALOG_WIDTH)
        dialog.setMinimumHeight(self.MIN_DIALOG_HEIGHT)


        vbox = PySide2.QtWidgets.QVBoxLayout(dialog)

        searchBar = PaletteLineEdit()
        searchBar.textChanged.connect(self.textChanged)
        searchBar.returnPressed.connect(self.returnPressed)
        searchBar.setMappings({
            PySide2.QtCore.Qt.Key.Key_Escape: self.escapePressed,
            PySide2.QtCore.Qt.Key.Key_Down: self.downPressed,
            PySide2.QtCore.Qt.Key.Key_Up: self.upPressed,
        })
        vbox.addWidget(searchBar)

        commandList = PySide2.QtWidgets.QListWidget()
        vbox.addWidget(commandList)

        for item in items:
            commandList.addItem(item)

        commandList.itemClicked.connect(self.runCommand)

        commandList.show()
        dialog.show()


        self.commandList = commandList
        self.dialog = dialog  # prevent dialog from being garbage collected


    def textChanged(self, newText):
        foldedText = newText.casefold()
        currentItemSet = False
        for i in range(0, self.commandList.count()):
            item = self.commandList.item(i)
            if foldedText in item.text().casefold():
                item.setHidden(False)
                if not currentItemSet:
                    self.commandList.setCurrentItem(item)
                    currentItemSet = True
            else:
                item.setHidden(True)

    def returnPressed(self):
        # Run the selected action.
        currentItem = self.commandList.currentItem()
        if currentItem is not None:
            self.dialog.hide()
            self.runCommand(currentItem)

    def escapePressed(self):
        # Cancel -- hide the dialog.
        self.dialog.hide()

    def downPressed(self):
        # Select the next unhidden action, if any.
        currentRow = self.commandList.currentRow()
        for i in range(currentRow + 1, self.commandList.count()):
            if not self.commandList.item(i).isHidden():
                self.commandList.setCurrentRow(i)
                return

    def upPressed(self):
        # Select the previous unhidden action, if any.
        currentRow = self.commandList.currentRow()
        for i in range(currentRow - 1, -1, -1):
            if not self.commandList.item(i).isHidden():
                self.commandList.setCurrentRow(i)
                return

    def runCommand(self, item):
        item.runTrigger()


palette = CommandPalette()
palette.activate()
