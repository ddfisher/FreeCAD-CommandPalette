# TODO: fuzzy search?
# TODO: better visuals:
#         see: https://stackoverflow.com/questions/41107202/pyqt-coloring-part-of-text-in-qlistwidget
#           - show the menu path to that item
#           - show the keyboard shortcut for the item


# Useful methods on QAction menu items
# text(): The text of the menu item with '&' before the shortcut key.
# toolTip(): on hover tooltip as html.
# shortcut(): shortcut keys for that action as a QKeySequence.
# trigger(): invoke that action.

# def go():
#     mw = Gui.getMainWindow()
#     menuBar = mw.menuBar()
#     enumerateActions(menuBar)

# def enumerateActions(menu, indent=0):
#     indentStr = "  " * indent
#     for action in menu.actions():
#         if action.isSeparator():
#             print(indentStr + "Separator action")
#         elif action.menu():
#             print(indentStr + f"Menu action: `{action.text()}`")
#             enumerateActions(action.menu(), indent + 1)
#         else:
#             print(indentStr + f"Action: `{action.text()}`")
    

# go()
import PySide2

def enumerateActions(menu):
    actionList = []
    for action in menu.actions():
        if action.isSeparator():
            pass
        elif action.menu():
            actionList.extend(enumerateActions(action.menu()))
        else:
            actionList.append(action)
    return actionList

def getMenuActions():
    mw = Gui.getMainWindow()
    menuBar = mw.menuBar()
    return enumerateActions(menuBar)

def getMenuItems():
    def convertAction(action):
        item = PaletteListWidgetItem()
        fixedText = action.text().replace('&', '')
        item.setText(fixedText)
        item.setSearchText(fixedText.casefold())
        item.setToolTip(action.toolTip())
        item.setIcon(action.icon())
        item.setTrigger(action.trigger)
        return item
    return [convertAction(action) for action in getMenuActions()]
    
class PaletteListWidgetItem(PySide2.QtWidgets.QListWidgetItem):
    _searchText = None
    _trigger = None

    def searchText(self):
        return self._searchText

    def setSearchText(self,text):
        self._searchText = text

    def runTrigger(self):
        self._trigger()

    def setTrigger(self, trigger):
        self._trigger = trigger

class PaletteLineEdit(PySide2.QtWidgets.QLineEdit):
    keyMappings = {}

    def keyPressEvent(self, event):
        keyFn = self.keyMappings.get(event.key())
        if keyFn is not None:
            keyFn()
            return

        super().keyPressEvent(event)

    def setMappings(self, keyMappings):
        self.keyMappings = keyMappings

class CommandPalette:
    def show(self):
        # items = ["one", "two", "three", "four", "five"]
        items = getMenuItems()
        dialog = PySide2.QtWidgets.QWidget()
        dialog.setObjectName("CommandPalette")
        dialog.resize(300, 300)


        vbox = PySide2.QtWidgets.QVBoxLayout(dialog)

        searchBar = PaletteLineEdit()
        searchBar.textChanged.connect(self.textChanged)
        searchBar.returnPressed.connect(self.returnPressed)
        searchBar.setMappings({
            PySide2.QtCore.Qt.Key.Key_Escape: self.escapePressed,
            PySide2.QtCore.Qt.Key.Key_Down: self.downPressed,
            PySide2.QtCore.Qt.Key.Key_Up: self.upPressed,
        })
        vbox.addWidget(searchBar)

        commandList = PySide2.QtWidgets.QListWidget()
        vbox.addWidget(commandList)

        for item in items:
            commandList.addItem(item)

        commandList.itemClicked.connect(self.runCommand)
        # print(commandList.count())

        commandList.show()
        dialog.show()


        self.commandList = commandList
        self.dialog = dialog  # prevent dialog from being garbage collected


    def textChanged(self, newText):
        foldedText = newText.casefold()
        currentItemSet = False
        for i in range(0, self.commandList.count()):
            item = self.commandList.item(i)
            if foldedText in item.text().casefold():
                item.setHidden(False)
                if not currentItemSet:
                    self.commandList.setCurrentItem(item)
                    currentItemSet = True
            else:
                item.setHidden(True)

    def returnPressed(self):
        # Run the selected action.
        currentItem = self.commandList.currentItem()
        if currentItem is not None:
            self.dialog.hide()
            self.runCommand(currentItem)

    def escapePressed(self):
        # Cancel -- hide the dialog.
        self.dialog.hide()

    def downPressed(self):
        # Select the next unhidden action, if any.
        currentRow = self.commandList.currentRow()
        for i in range(currentRow + 1, self.commandList.count()):
            if not self.commandList.item(i).isHidden():
                self.commandList.setCurrentRow(i)
                return

    def upPressed(self):
        # Select the previous unhidden action, if any.
        currentRow = self.commandList.currentRow()
        for i in range(currentRow - 1, -1, -1):
            if not self.commandList.item(i).isHidden():
                self.commandList.setCurrentRow(i)
                return

    def runCommand(self, item):
        item.runTrigger()


palette = CommandPalette()
palette.show()
